

注意以后写方法，大部分可以写成无返回值的，因为比如说下面这个方法，上传通话录音文件，如果抛出异常了，在controll层直接返回错误给调用端即可，
不需要再返回什么boolean,
public void saveCallRecordingFile(String userCustomerCallId, MultipartFile file) throws Exception;
还有
if(customerMapper.inser(entity)>0){
	customerDetailMapper.insert(detailEntity);
}
像上面这种代码也不要再这样写了，因为保存出错，就会回滚，根本不需要判断什么insert后是否成功或失败
customerMapper.inser(entity);
entity.getId();
customerDetailMapper.insert(detailEntity);
直接这样写就行了


public boolean existsCustomerTagGroupDetailName(String itemId, String itemDetailName) {
		List<CustomerTagGroupDetailEntity> list = customerTagGroupDetailMapper.selectList(new QueryWrapper<CustomerTagGroupDetailEntity>()
				.eq("customer_tag_type_id", Integer.parseInt(customerTagTypeId))
				.eq("customer_tag_name", customerTagName));
		if(list!=null && list.size()>0){
			return true;
		}
		return false;
	}
	像这种方法就没有书写的必要
	public List<CustomerTagGroupDetailEntity> queryCustomerTagGroupDetail(String itemId, String itemDetailName) {
		List<CustomerTagGroupDetailEntity> list = customerTagGroupDetailMapper.selectList(new QueryWrapper<CustomerTagGroupDetailEntity>()
				.eq("customer_tag_type_id", Integer.parseInt(customerTagTypeId))
				.eq("customer_tag_name", customerTagName));
		return list;
	}
	改成这种，是不是更通用呢? 既有查询的功能，又有判断存不存在的功能


 public static String createRedisKey(HttpServletRequest request) throws
            Exception {
        String paramStr = request.getRequestURI();
        Map<String, String[]> parameterMap = request.getParameterMap();
        if (parameterMap.isEmpty()) {
            paramStr += IOUtils.toString(request.getInputStream(), "UTF-8");//注意这里是拿request请求体body中的数据，这个流只能获取一次，不能多次获取
        } else {
            paramStr += mapper.writeValueAsString(request.getParameterMap());
        }
        String redisKey = "WEB_DATA_" + DigestUtils.md5Hex(paramStr);
        return redisKey;
    }


树形组件，都需要在下面添加一个查看节点，用来显示上一级的菜单，这个elementUI是这样的

以后写sql都使用左连接吧
<select id="searchUsers" resultMap="BaseResultMap">
        SELECT a.id as id ,a.create_time as create_time, a.create_by as create_by,a.update_time as update_time,a.update_by as update_by
        ,a.user_id as user_id,a.password as password,a.realname as realname,a.type as type,a.mobile as mobile
        ,a.email as email,a.remarks as remarks ,a.status as status,a.avatar as avatar,a.sex as sex
        ,c.name as role_name,c.role_id as role_role_id ,e.org_id as org_id,e.simple_name as simple_name,g.code as code,g.url as url
        from sys_user a
        LEFT JOIN  sys_user_role b on a.user_id=b.user_id
        LEFT JOIN  sys_role c on b.role_id=c.role_id
        LEFT JOIN sys_user_org d on a.user_id=d.user_id
        left JOIN sys_org e on d.org_id =e.org_id
        left join sys_role_menu f on f.role_id=c.role_id
        left join sys_menu g on g.code=f.menu_code
        <where>
            <if test="userId != null and userId!='' ">
                a.user_id = #{userId}
            </if>
            <if test="realname != null and realname!='' ">
                AND a.realname = #{realname}
            </if>
        </where>
    </select>
像这种其实是关联了多个一对多的表，然后返回的是一个主表的数据，如果有需要返回一对多，切记不要再使用 from a,b where a.id=b.id这种搞法了，
应该采用返回json结构，一对多的写法
	

mysql 主从架构，读写分离，其实说的是一个东西


如果每个表或者大部分表，都需要有create_date_time ，update_date_time字段，则可以新建一个basePojo类，让有需要的实体类继承这个类
@Data
public abstract class BasePojo implements java.io.Serializable{
	private Date createDateTime;
	private Date updateDateTime;
}

@Data
public abstract class BasePojo implements java.io.Serializable{
	private LocalDateTime createDateTime;
	private LocalDateTime updateDateTime;
}



数据库设计：如果想设计比如某一个字段没有值就不属于分校，比如branchOrgId为""则不属于任何分校，以后还是不要这样设计了，因为为空的话，在数据库里面有很多种，比如"" null 等，
以后还是使用为0来代替吧，0也是没有的意思，因为设计为0的话，在写查询条件的时候，也好写一些，与前台进行接口对接也好对接一些，你的接口还可以设计默认值为0

//注意，如果你的启动项目中没有配置url的话，则需要去年如下的自动配置类，否则启动报错
@SpringBootApplication(exclude= {DataSourceAutoConfiguration.class})

在实体类中定义：
	@JsonIgnore
    private String password;// 密码
	@JsonIgnore
    private String salt;// 密码的盐值
注意：为了安全考虑。这里对password和salt添加了注解@JsonIgnore，这样在json序列化时，就不会把password和salt返回


CREATE TABLE `tb_user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `username` varchar(50) NOT NULL COMMENT '用户名',
  `password` varchar(32) NOT NULL COMMENT '密码，加密存储',
  `phone` varchar(20) DEFAULT NULL COMMENT '注册手机号',
  `created` datetime NOT NULL COMMENT '创建时间',
  `salt` varchar(32) NOT NULL COMMENT '密码加密的salt值',
  PRIMARY KEY (`id`),                                          ------注意这里是主键，并且也是索引
  UNIQUE KEY `username` (`username`) USING BTREE               ------注意这里是唯一性约束，同时也是唯一性索引，还有外键foreign key索引，不过外键索引一般我们都不用
) ENGINE=InnoDB AUTO_INCREMENT=28 DEFAULT CHARSET=utf8 COMMENT='用户表';



少量的一对多，比如一个商品，即sku的图片，充其量也就4-5张，这就不需要再设计一个一对多的表出来了，直接存储在sku的image字段上，通过逗号分隔即可


https://item.taobao.com/item.htm?spm=a21ka.8063459.319593.40.44f55602C0ofx0&id=8720562031
https://item.jd.com/4155894.html#product-detail
从以上淘宝，京东的商品详情页的地址可以看出，京东使用自增的搞法，淘宝使用的是自研的算法id来生成商品的id
下一次做项目，所有id都采用uuid不要再采用别的了，如果你的项目做了分库分表，数据迁移，使用自增，都玩不转了


后面非常简单的sql就写到代码里面吧，复杂的就写到xml配置文件里面去，如果都写xml里面去，xml也显得很臃肿
@Select("SELECT b.* FROM tb_brand b LEFT JOIN tb_category_brand cb ON b.id=cb.brand_id WHERE cb.category_id=#{cid}")
    List<Brand> queryBrandByCategoryId(Long cid);
优化如下：
1. 单表，完全可以使用通用mapper或者mybatis plus框架，不用写sql
2. 简单的多表，就采用上面的方式写到java代码里面也没关系
3. 还有简单的一对多，就直接写在xml里面通过connections关联起来就可以了


像现在的客户表，完全可以拆分成两个表，基础表，只提供最简单的信息，然后复杂的信息，都搞到客户详情表里面去，主要是为了从海量的客户数据里面分页得到前面50条，
或者100条，然后再一条一条通过java再发起查询去组装数据，这样效率都高一些


CREATE TABLE `tb_category`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '类目id',
  `name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '类目名称',
  `parent_id` bigint(20) NOT NULL COMMENT '父类目id,顶级类目填0',
  `is_parent` tinyint(1) NOT NULL COMMENT '是否为父节点，0为否，1为是',
  `sort` int(4) NOT NULL COMMENT '排序指数，越小越靠前',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `key_parent_id`(`parent_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1424 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '商品类目表，类目和商品(spu)是一对多关系，类目与品牌是多对多关系' ROW_FORMAT = Compact;
当需要做点击叶子节点再展现具体的商品这种需求时，就需要搞叶子节点这种设计，一般的菜单层给，组织架构层级，不需要这种设计


对于面包屑，我觉得还在存到数据库里面，省得需要的时候，每次还去单独根据ids去加载，效率肯定低啊，乐优就是这样做的

一对一的表，其实可能就是扩展表，可以没有id属性，这个表的id就是主表的id做主键，这样更精简

难怪乐优的库里面           parent_id
1	图书、音像、电子书刊	0	1	1
74	手机	                0	1	2
103	家用电器				0	1	3
202	数码					0	1	4
264	家居家装				0	1	5
以上的数据全是parent_id为0的数据，像这种分类数据太大了，他没有做整个树形数据全部一次性计出来，而是默认传一个0来解决的

目前crm直接将客户的数据查出来，客户的分校，及组织什么的，都额外查出来，给前端去用，这样还是不太好，不过也可以这样做
优点，减少接口调用
缺点，代码逻辑混乱


虽然用了mybatis plus，但是非常简单的sql语句，也可以写在代码里面，防止xml文件中的sql语句过于庞大
/**
     * 根据品牌id查询商品分类
     * @param bid
     * @return
     */
@Select("SELECT * FROM tb_category WHERE id IN (SELECT category_id FROM tb_category_brand WHERE brand_id = #{bid})")
List<Category> queryByBrandId(Long bid);


联合主键用法
CREATE TABLE `tb_category_brand` (
  `category_id` bigint(20) NOT NULL COMMENT '商品类目id',
  `brand_id` bigint(20) NOT NULL COMMENT '品牌id',
  PRIMARY KEY (`category_id`,`brand_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='商品分类和品牌的中间表，两者是多对多关系';


数据库设计：当布尔类型的才设计为tinyint(1)，像下面的，根本就不是布尔类型，设计为这样，那么自动生成代码，则会使用Boolean代替，
`payment_type` tinyint(1) UNSIGNED ZEROFILL NOT NULL COMMENT '支付类型，1、在线支付，2、货到付款',
如果硬是要节省这点容量的话，那就使用tinyint(1)吧，生成代码后，自己手工把Boolean改为Integer吧，以后再新增字段，就不要使用覆盖的方式，手工新增一个到pojo里面去
tinyint

从 -2^7 (-128) 到 2^7 - 1 (123) 的整型数据。存储大小为 1 个字节。
int

从 -2^31 (-2,147,483,648) 到 2^31 - 1 (2,147,483,647) 的整型数据（所有数字）.存储大小为 4 个字节。


金额统一采用：bigint，还是要使用bigint,因为int才20亿，即使无符号也就40亿，而且你还是使用分为单位，那么其实最大就只有2亿与4亿了，太小了，
占用8个字节就8个字节吧
如下：
`post_fee` bigint(20) NOT NULL COMMENT '邮费。单位:分。如:20007，表示:200元7分',


tinyint
从 -2^7 (-128) 到 2^7 - 1 (123) 的整型数据。存储大小为 1 个字节。
unsigned 是从 0 到 255 的整型数据。
所以建表的时候 只能是tinyint(3),哪怕你建tinyint(100)，他最大还是3位这么多。

smallint
从 -2^15 (-32,768) 到 2^15 - 1 (32,767) 的整型数据。存储大小为 2 个字节。
unsigned 是从 0 到 65535 的整型数据。
所以建表的时候 只能是smallint(5),哪怕你建smallint(100)，他最大还是5位这么多。

int
从 -2^31 (-2,147,483,648) 到 2^31 - 1 (2,147,483,647) 的整型数据（所有数字）.存储大小为 4 个字节。
unsigned 是从 0 到 4294967296 的整型数据。
所以建表的时候 只能是int(10),哪怕你建int(100)，他最大还是10位这么多。


bigint
从 -2^63 (-9,223,372,036,854,775,808) 到 2^63-1 (9,223,372,036,854,775,807) 的整型数据（所有数字）。存储大小为 8 个字节。
unsigned 是(自己算吧)
所以建表的时候 只能是bigint(20),哪怕你建bigint(100)，他最大还是20位这么多.



@Table(name="tb_category")
public class Category {
	@Id
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	private Long id;
	private String name;
	private Long parentId;
	private Boolean isParent; // 注意isParent生成的getter和setter方法需要手动加上Is ,	这可能是原来的ide2017版本，现在都没这个问题了，现在的就是我生成的，有自动带上
	private Integer sort;
	// getter和setter略
}
public String getIsParent() {
    return isParent;
}

public void setIsParent(String isParent) {
    this.isParent = isParent;
}
	

***
一对一的表，也可以设计成关联表，比如订单表--》订单状态表
一个订单，只会存在一个状态，但是为什么要设计一个订单状态表呢？
DROP TABLE IF EXISTS `tb_order_status`;
CREATE TABLE `tb_order_status`  (
  `order_id` bigint(20) NOT NULL COMMENT '订单id',
  `status` int(1) NULL DEFAULT NULL COMMENT '状态：1、未付款 2、已付款,未发货 3、已发货,未确认 4、交易成功 5、交易关闭 6、已评价',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '订单创建时间',
  `payment_time` datetime(0) NULL DEFAULT NULL COMMENT '付款时间',
  `consign_time` datetime(0) NULL DEFAULT NULL COMMENT '发货时间',
  `end_time` datetime(0) NULL DEFAULT NULL COMMENT '交易完成时间',
  `close_time` datetime(0) NULL DEFAULT NULL COMMENT '交易关闭时间',
  `comment_time` datetime(0) NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT '评价时间',
  PRIMARY KEY (`order_id`) USING BTREE,
  INDEX `status`(`status`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '订单状态表' ROW_FORMAT = Compact;
因为订单的状态，会经常修改

设计了一个spu_detail表，里面的字段，全是商品描述，商品详情等大字段，当我只需要查看比如购物车商品时，这些大字段，就不需要查出来了，影响效率
这个也是一对一的关联表

DROP TABLE IF EXISTS `tb_stock`;
CREATE TABLE `tb_stock`  (
  `sku_id` bigint(20) NOT NULL COMMENT '库存对应的商品sku id',
  `seckill_stock` int(9) NULL DEFAULT 0 COMMENT '可秒杀库存',
  `seckill_total` int(9) NULL DEFAULT 0 COMMENT '秒杀总数量',
  `stock` int(9) NOT NULL COMMENT '库存数量',
  PRIMARY KEY (`sku_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '库存表，代表库存，秒杀库存等信息' ROW_FORMAT = Compact;
也是频繁更新，所以库存表，也独立成一张表


mybatis resultType  resultMap
mybatis parameterMap parameterType
parameterMap
这是引用外部 parameterMap 的已经被废弃的方法。请使用内联参数映射和 parameterType 属性。
parameterType,*************不需要再声明此参数了，可以自动转化
将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler） 推断出具体传入语句的参数，默认值为未设置（unset）。
resultType
从这条语句中返回的期望类型的类的完全限定名或别名。 注意如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身。可以使用 resultType 或 resultMap，但不能同时使用。
resultMap
外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂映射的情形都能迎刃而解。可以使用 resultMap 或 resultType，但不能同时使用。


https://www.cnblogs.com/yaowen/p/8862108.html
mysql中int(3)与int(11)有什么区别吗？
注意：这里的M代表的并不是存储在数据库中的具体的长度，以前总是会误以为int(3)只能存储3个长度的数字，int(11)就会存储11个长度的数字，这是大错特错的。
其实当我们在选择使用int的类型的时候，不论是int(3)还是int(11)，它在数据库里面存储的都是4个字节的长度，在使用int(3)的时候如果你输入的是10，会默认给你存储位010,也就是说这个3代表的是默认的一个长度，当你不足3位时，会帮你不全，当你超过3位时，就没有任何的影响。
前天组管问我 int(10)与int(11)有什么区别，当时觉得就是长度的区别吧，现在看，他们之间除了在存储的时候稍微有点区别外，在我们使用的时候是没有任何区别的。int(10)也可以代表2147483647这个值int(11)也可以代表。

像性别，类型，种类，原来定义成varchar(1),有些文章定义int(1)这些，都没什么意义，扩展性还不好，以后统一，定义一个int即可
但是tinyint(1)这种是有必要的，1个tinyint型数据只占用一个字节;一个INT型数据占用四个字节。
而且编码的时候，可以使用true,false来编码

****
目前mybatis plus自动生成的代码，没有生成toString方法，如果有toString（）,那么你需要打印这个对象的时候，就可以直接打印了


以后金额字段，使用bigint类型即可，上面存储类型为分即可，就不再需要BigDecimal类型了，前端展现的时候除以100，请求到数据库里面

*********
返回时间格式化问题，已经在CRM的公告模块解决了：
<select id="getNoticeById" resultMap="defaultMap" parameterType="string">
    	select a.*,b.user_name as release_user_name from crm_notice as a, sys_user as b 
    		where 
    			a.release_user_id=b.id  and a.id=#{id}
    	
	</select>
*********

其实在mybatis自定义sql，返回map结果集
 <select id="getBranchCustomerByMobile" resultMap="defaultMap"  parameterType="java.util.Map">
 这种有很多缺点：
1.从数据库里面查询出来的时间字段，中间带有T,而且无法使用全局办法去掉
2.查出来的结果集，是数据库里面定义的字段，比如user_name,而不是返回userName
 <select id="getBranchCustomerByMobile" resultMap="BaseResultMap"  parameterType="java.util.Map">
如果返回BaseResultMap，因为这个BaseResultMap在上面已经做了字段与属性的映射就没有问题
可是又只能返回固定的列，比如要再多返回一些，就自己再去定义BaseResultMap吧
3.如果你使用了order by字段，那么此字段如果是时间字段，如果你在上面此字段进行了date_format(b.create_time,'%Y-%m-%d %H:%s:%s') as create_time,那么排序就乱七八糟了

以后写代码，有事务的方法体内
比如先删除，再新增，再修改这些操作，直接写就是了，不需要去判断，比如删除返回的影响记录行数是否大于0，因为你执行删除就删除，如果报错，后面就不会执行了啊，你还要去判断干嘛，
万一你删除一个系统中暂时不存在的数据，你后面的逻辑难道就不执行了吗？，所以压根就不需要去判断影响的行数了

****
下一次搭建框架：
所有主键都可以采用uuid，树形结构已经稳定，不用考虑使用int类型来设计菜单及组织节点了，这样可以避免与前端联调的时候，参数过来都是String型，还要大量转为Integer，增加不必要的工作量
基本上都不需要去使用int类型了，因为做了自增长，在数据迁移的时候，很麻烦，最多可以定义一个表中的，比如int 1男  2女，不过也没这个必要，varchar(1)这样，不香吗？看后面，这种使用char(1)速度还快些

菜单跟组织，上下级，全都使用uuid来做，注意那么parant_ids的长度一定要设置得足够长，至少存5极的话，就是32*=160，那么长度设置为200，就可以存32*6=192+6（个逗号）=198，200绝对够了

不用每个表都定义没语义的id主键，有的关联表，可以直接是主表的id作主键，不需要再定义一个id字段，比如，订单明细表的主键就可以直接为order_id，即来自订单表的id

**************************************************************************************************
下一次搭建框架，mybatis plus自带的分页其实只适合于，整个业务系统中没有很多关联的表，然后加载单表的数据进行分页，需要查询几个表的结果，然后提供分页，plus这个框架根本就搞不定
<sql></sql>  <include></include>这个标签可以用起来，解决现在的customerMapper.xml里面定义了很多重复的sql语句
比如有多表，不仅仅是需要返回客户的数据，还需要顺带user的数据的返回结果集，返回java.util.HashMap没有问题
<sql id="userColumns"> ${alias}.id as id, ${alias}.user_name as userName, ${alias}.pass_word as passWord</sql>
select 
	<include refid="userColumns"><property name="alias" value="a"/></include>,
	b.user_id as userId
	from crm_customer as a, crm_user_customer as b where .....
这样就解决了mybatis plus框架，自带的api查询，与自己书写sql返回的结果集，有的是带_线的，有的是骆峰命名的问题

defaultMap这个也不需要再命名了，LinkedHashMap这个也不再需要使用了，前台是不关注你的顺序的

感觉这个作用不大了，我只需要去整改上面写的BaseResultMap就行了，你查询出来的列，有BaseResultMap与之对应，不就行了


<select id="getCustomerListByRepository" resultMap="java.util.HashMap"  parameterType="java.util.Map">
注意以后返回类型写HashMap,参数类型写Map就行了，其实你也可以写HashMap，你写HashMap，下面的方法就无法定义成Map<Object, Object> map
</select>

public List<Map<Object, Object>> getCustomerListByImport(Map<Object, Object> map); 以后这样写代码
***********************************************************************************************



****************************************测一下下面的问题
Customer customer = new Customer();
customer.setId(id);
customer.setName(name);

customerMapper.updateById(customer);
-----上面这种写法容易出现问题，不够严谨

Customer customer = this.getById(customerId);
if(customer!=null){
	customer.setId(id);
	customer.setName(name);

	customerMapper.updateById(customer);
}else{
	throw new BussnisException("xxxxx");
}

-----这种才比较严谨，因为会把数据库里面加载出来的字段为''的设置为null，使用this.getById(customerId);先把数据库里面查出来，再去更新，则不会出现这个问题
有时间测试一下最新版本的mybatis plus有没有这个问题，反正对应一条数据库为''的属性，会更新为null
				CustomerEntity entity = new CustomerEntity();
				entity.setDeleteUserId(bean.getId());
				entity.setDeleteDateTime(LocalDateTime.now());
				entity.setState("1");//状态	state	1：进入回收站，2：已删除
				entity.setDeleteCauseId(Integer.parseInt(causeId));
				entity.setDeleteCause(cause);
				
				customerMapper.update(entity, new UpdateWrapper<CustomerEntity>().in("id", customerIdList));  使用这种方式测一下
****************************************测一下下面的问题




existsCustomerByMobile  像这种方法基本上就是浪费，根本就不太需要
比如： getCustomerListByMobile(String mobile) 这种方法就通用得多，不仅可以返回结果集，还包含上面那个功能，如果list结果集为空，就是不存在啊，
不过为了代码的精练，也还是可以定义一些这样的方法，不做太多要求吧

除了id，其他的比如多个表存在name，还是要进行区分，要带有语义，比如设计为org_name,user_name
id其实也最好带有语义，这样关联的表里面的id也可以定义成一样的，可以做到全库都是一样的，最好这样

org_id  org_state  org_type  org_name 以后全部采用这样命名，这几个是最频繁的，表之间重名最高的,算了，这个是为了解决自己改造的swagger上面的接口定义问题，我看别人黑马都没有这样命名的

create_by_id 创建人ID    create_by_name 创建人名称
update_by_id 修改人ID    update_by_name 修改人名称
create_date_time   create_date   create_time
update_date_time   update_date   update_time

sort_num 排序号，全系统所有排序可以使用这个 

description 备注，描述，采用这个单词

权限系统，菜单一定要可以直接赋值给用户

目前的设计一个人只能出现在一个组织架构下面，如果下一次设计，一个人比如在多个生产车间工作，这种是不是要挂到多个组织架构下面？  所以以后还是不要在用户表里面冗余组织结构字段了
目前搞冗余，主要是为了拼接好部门名称存起来，其实只需要这个属性就可以了，不需要冗余org_id

点组织架构，只加载当前节点下面的员工，不需要加载子孙节点下面的员工了，因为进行了权限控制，不能全加载出来，混在一起，以后做也不要再做混在一起全加载出来的逻辑了，
如果同一个人挂在不同的组织节点下，全部查出来，还要去重操作

新增员工的时候，可能还要加一个数据域，比如能查看哪些数据
-- data_scope:当前用户的权限域
-- 所有数据	0
-- 自己的数据	1
-- 仅所属部门数据	2
-- 所属部门及其以下所有数据	3    这种还是解决不了，目前拥有多个分校，要查看多个分校及分校下的部门的权限，比如区域管理员
以后这种方案可能用得上，也可能用不上

1. 要注意除了一维的数据字典，还有二维的数据字典，比如客户来源--》客户来源明细     ，  客户标签--》客户标签明细，
	可以通过一个表专门来存储这种二维的数据，而且还不用去定义值，直接使用id即可，使用int自增长，同样的定义一个标签名
	,其实最好的设计就是
	sys_dict,sys_dict_detail两个表，当只有一维的时候，使用第一个表存，有二维的时候，使用第二个表存，使用id关联，id即数据字典的值即可
	这种也只能定义写死的，自己后台维护的数据字典，如果像需要前端用户自己输入客户标签--》客户类型--》个人客户，集团客户  还是要单独建表去处理，因为你定义不了tag标签名
	***********************************************************************************************
	****注意，最好数据字典还是只有一张表即可，像这种客户自定义的分组，标签，做成二维的，还是定义2张单独表去给用户操作使用******
	***********************************************************************************************
	
2. 创建时间统一采用create_date_time ,创建日期统一使用create_date,方便自己，也方便前端人员使用
	update_date_time   update_date 跟数据库里面的datetime   date对应，也跟jdk8开始提供的LocalDate  LocalDateTime对应

3.  以后不需要每个Mapper.xml文件里面定义一个defaultMap了，直接使用下面的resultType="java.util.HashMap" 即可，对于前端而言，是不需要顺序的，
	他们对于你定义的属性都是陌生的
	<select id="findBrancheOrgIdContractCount" resultType="java.util.HashMap"  parameterType="java.util.Map">

4. 接口返回Result时，要保证自己写的sql查询出来的列，与mybatisPlus框架返回的结果一致，就需要自己写sql时，将查询出来的每列都 as一下
	如：  select user_name as userName, org_name as orgName这样转，可以确保每个接口返回的列是一致的
	
5. 主外键关系图：箭头所指的位置为主键，即箭头指向到那个表的位置，即那个表是主键，其他的是外键

6. 创建时间createDateTime(包含日期与时间)时间肯定就包含日期的，  创建日期createDate(只包含日期),与JDK8的命名保持一致
	LocalDateTime  LocalDate   LocalTime  日期是日期，时间是时间

7.  像权限标识符，sys:report:customerListByCustomerManage:view
	命名规则，直接采用  sys:模块名：方法名：动作（查看，导出，删除等）  直接copy方法名进来，便于查找与分析问题，不要采用何辉组老式的命名方式
	
8. 在xml里面自定义的sql，比如查询的方法，最后面一句：limit #{startRow}, #{pageSize}
	可以这样改写：
	<if test="startRow !=null">
		limit #{startRow}, #{pageSize}
	</if>
	这样的代码，可以更通用，当不需要分页的地方调此方法此，就不再需要传递startRow与pageSize参数了

9. 自定义注解全局记录日志，这个切面编写得不错，比原来的安证通他们包装的要好很多
	https://blog.csdn.net/hry2015/article/details/80244765

10. 方法命名：
	getBranchOrgByUserId  比如这就是获取分校的，目前在实现的时候就写错了，应该按如下命名：
	getBranchOrgListByUserId 获取用户分校集合   getBranchOrgByUserId 获取用户所在的分校
	是返回集合的方法一定要有list字样
	上面的都是通过简单的参数get获取的，比如有查询条件的，命名应该如下：
	findUserListByOrgId 这种方法里面就是带有员工姓名之类的查询条件的
	如果查这个机构下的用户（包含子孙节点），则命名如下
	findUserListByOrgIdAndChildren
服务层方法定义：
当接口返回的是哪个实体类型，则此方法定义至相应的控制层里面去，便于接口归类，比如用户的接口统一在用户的Control类中，角色的接口统一在角色的Control类中
发布出去的接口，返回的是OrgEntity集合，则全部定义在OrgControl类中
发布出去的接口，返回的是UserEntity集合，则全部定义在UserControl类中

表与表之间的关联，还是不要设计很多冗余字段，虽然有些查询可以减少表的关联个数，但更新一些数据的时候，需要关联的表都需要修改
那么修改的工作量就大了

设计表，尽量字段采用带有语义的名称，比如crm_org表中的name就定义为 org_name
crm_customer 中的name就定义为customer_name
这样在前后端传值，以及关联查询的时候，就会自动区分开来，不用再去人为的  
select a.name as org_name, b.name as customer_name from crm_org as a, crm_customer as b
像没有语义的设计，必然带来上面的问题

数据库字段命名，还是使用下划线，比较好
https://www.v2ex.com/t/584189
如果使用驼峰命名，那么在书写自定义 sql的时候，会不习惯，还可能会带来其他的问题，但就是目前自定义sql如果使用select * from 返回的话，就不是驼峰命名的了，也可以做到，返回BaseMap,不要返回自己的defaultMap即可


？？？？  目前只在sql里面实现了通过传一个组织节点，加载其下的子孙节点，无法传多个，其实这个多个如果是固定的就可以使用union拼接起来，但这个多个是动态的，无法实现，貌似只有存储过程
其实不写存储过程，使用mybatis的循环标签，也可以动态接sql出来
 <foreach item="item" index="index" collection="list" 
                    open="(" separator="," close=")">
                   #{item}
            </foreach>
            或者在java代码里面拼出来

1.所有实体类，都必需自动生成带Entity的后缀,这个还是加吧
2.所有接口层，都必需自动生成带 I 开头的前缀,这个还是可不加，Spring Security框架中的UserDetailsService接口，别人都没加
3.Mybatils plus可以考虑升级为最新的版本
4.使用 https://fooler5.iteye.com/blog/2414894   Api2Doc 这个比swagger好用，但没有测试的功能
5. 使用睿展的那一套pom，可以在上面去掉蓝凌的工具包，因为这个里面集成了热部署的，原来crm那一套热部署没搞好，其实少量改动也不用重启也是生效的
6. 下一次做项目树形采用jdk8的做法来做，目前已经集成在test包下tree,tree2两种写法，一种是使用Integer,Long，
    不过使用jdk8只能存在一个根节点，而且这个根节点必需存在，安证通以前那种写法可以不存在根节点，只需要配哪些节点指向0就行
	根节点一定不能省啊，会存在很多问题，配了根节点0,2  这个就不需要再配上自己了，如果不配根节点，需要0,2,3 这样配上自己
	**就用现在写好的这一套，指定根节点也是没问题的
****

---------------------------以后就使用varchar32做主键，一些男女，客户类型，就使用   姓别：sex  char(1)  客户类型 customer_type char(2)
----------------------使用char类型，用mybatis plus自动代码生成工具，生成的类型也对应的是String，这样在前后端参数传递方面，方便很多
相同条件下的查询速度：
char(1)和tinyint一样；
char(2)和smallint一样；
char(3)的性能介于smallint和int之间；
char(4)和int一样；
char(5)则比int慢，但比bigint快。

一般来说，在相同的索引条件、数据量、数据分布的情况下：
1. 定长字段比变长字段稍快；
2. 同样是定长字段，字段空间越小越快。

但这种性能差别没什么意义，跟合理加索引带来的性能提升相比几乎可以忽略。
设计数据表的时候，字段选择什么数据类型，主要根据字段的逻辑含义和值域要求，而不是这一点的性能差别。


原来的POM系统，基础物料表，下面的组分，成品，原料统统属于物料，其实原来还讨论过是否存储至一张表里面，幸好没有存到一个表里面，这其实就是表的纵向拆分，使用ID做关联即可


注意： xml文件是自定义sql当需要判断参数是否为空，是否相等下，注意以下区别：
----------------------------如果不需要判断等于具体的数值，是''括起来,注意是单引号
<choose>
<when test='userType !=null and userType !="null" and userType !="" and userType=="1"'>
</when>
<otherwise>
</otherwise>
</choose>

----------------------------如果不需要判断等于具体的数值，是“”括起来，注意是双引号
<when test="customerTagIdList !=null and customerTagIdList !='null' and customerTagIdList !=''"> 


注意，像Map<Object, Object> 结构这样定义，在组装查询参数时，一定需要注意查询的类型，
Map<Object, Object> paramMap = new HashMap<Object, Object>();
            paramMap.put("startRow", PageUtil.getStartRow(pageNum, pageSize));
            paramMap.put("pageSize", Integer.parseInt(pageSize));  
如果这个pageSize是String类型，那么在传到后端xml文件里面去的时候，会自动转成,如 limit  0,'10' 这样的结构出来---------------------------
,
需要注意的是，比如这个pageSize你在put的时候指定为Integer类型了，然后你在xml文件里面又如下书写
<if test="pageSize != null and pageSize  != 'null' and pageSize  !=''">  那么就会报错：NumberFormatException: For input string: "null"
原因就是你put的时候是int类型，去使用的时候，你又当字符串去使用



一、数据库和UUID方案的不足之处

采用数据库自增序列：

读写分离时，只有主节点可以进行写操作，可能有单点故障的风险
分表分库，数据迁移合并等比较麻烦
UUID随机数：

采用无意义字符串，没有排序
UUID使用字符串形式存储，数据量大时查询效率比较低





亿级数据查询，分页    https://blog.csdn.net/hry2015/article/details/80212708
[上一页]1， 2，[3]，4，5 [下一页]，不去统计总页数，只进行相应的查询即可，分页组件要做特殊优化



可以直接使用这个注解声明这个类作为一个组件，在需要使用的地方通过@Autowired注入使用即可，我原来还以为只能通过接口的方式，不过有事务的控制就还得使用接口，
这种只适合为工具类的组件，不用使用new去创建对象了
@Component   
public class EmitLog {
  
      @Value("${spring.rabbitmq.exchange}")
     private String exchange;
 
     @Autowired
     private AmqpTemplate amqpTemplate;
 
     public void send(String msg) {
         amqpTemplate.convertAndSend(exchange,"",msg);
     }
 }
 
 在需要使用的地方使用：@Autowired注入使用即可，
 @Autowired
 private EmitLog emitLog;


------重要
树形菜单，重要事项：
其实我设计了org_type类型，你只需要select * from 把所有的节点加载进来，然后自动通过java代码去组装成树形结构就可以了
orgList.sort((o1, o2) -> o1.getOrderNum().compareTo(o2.getOrderNum()));  比如这里还添加了排序的功能
		findChildren(tempOrgList, orgList);
		
select 
			id,parent_id,parent_ids,org_name,org_type,state,order_num,remark,province_id,province_name,
			city_id,city_name,area_id,area_name,full_name_path,create_time 
		from (
            	select t1.*,
             			if(find_in_set(parent_id, @pids) > 0, @pids := concat(@pids, ',', id), 0) as ischild
             				from (
                 				select * from sys_org t where t.state='1'  order by parent_id, id
                 		) t1,
                	(select @pids := #{orgId}) t2
            	) t3 where ischild != 0	



java代码技巧：
1. //获取用户的角色列表
	private String userRoleListUrl = "role/%s/user/%s/roles";  //role/{appId}/user/{userId}/roles;
	/**
	 * 获取用户的角色列表
	 * @return
	 */
	public String getUserRoleListUrl(String userId) {
		return  String.format(this.userRoleListUrl, CoreConfig.MY_APP_ID, userId);
	}

2. String.valueOf(name);  此方法不论name传的为何内容，都不会报空指针

3.




Alt+Shift+D+J  以debug模式运行
Alt+Shift+S+V  当实现层有未实现接口层方法报错时，快捷方式实现未实现的方法

Tab键，可使选中的代码向右移，使用shift+Tab键可使选中的代码向左移

待解决的问题：
1. **** 目前token一直需要来回传，应该是cookie没保存，或者是我的程序没有把cookie用起来的原因。。。。
	可参考业务办理平台的cookie方案，我的肯定是cookie没起作用
2. ****用户登录的时候，就把user对象或者vip对象给返回回去，但后面认证了，绑定了银行卡了，这些操作，难道刷新一下subject吗？
	他们每个逻辑前，都调用用户是否认证？  或者调用获取当前用户信息接口获取用户所有信息？
3. 长时间登录状态保持解决方案(即认证，记住我功能)：
	https://blog.csdn.net/gaofeihu_/article/details/79447922  
	https://blog.csdn.net/u014437791/article/details/88983902
4. 免密码登录：
	https://blog.csdn.net/ljh1993531/article/details/82591524
5.shiro学习分享(三)——解决跨域问题时遇到的坑，shiro跨域问题，里面也有springboot跨域
	https://blog.csdn.net/madonghyu/article/details/80027387
	https://www.jianshu.com/p/89a377c52b48  这个讲得很详细
	https://www.jb51.net/article/121548.htm 

2. ShiroRealm中打 ？？问号的问题，缓存没使用起来，每个请求，都会查询一下数据库
3. ShiroConfig中 hashedCredentialsMatcher()方法，操作密码相关，目前我是使用简单的比较md5的方式，
	到时候升级为加密盐的方式，这个方法是参考合同中的，没有完整的移植过来,,用户注册接口保存密码的时候，目前也是md5保存的，后面要升级为加密盐的方式
	PasswordUtil这个工具类，从统一电子权限平台移植过来的，里面md5进行了5次加盐，其实应该拿userId进行加盐，才是最理想的方式

4. swagger现在升级成2.9.2版本了，自定义的json参数没有按自己书写的顺序进行展现,按首字母进行排序的，这在json参数少的情况下不受影响，在参数多的情况下，则会有影响

5. 如果要开发记住我功能，请看下面的文章 ：
	https://blog.csdn.net/xtiawxf/article/details/52625104
	https://blog.csdn.net/u014437791/article/details/88983902
	
6. Mybatis plus连sum一列上的求和功能都没有，看来这个框架离成熟，还有很长一段距离，不过单表操作真的是无敌，分页等还是很方便
7.  
8.  限制同一个账号，只能在一处登录，未做,合同项目中ShiroConfig有下面的代码实现
// 自定义 session 管理, 防止重复登入问题
		securityManager.setSessionManager(sessionManager);
终极版（这个非常值得看，目前还有剔除前一个账号登录的问题还没做）：
https://blog.csdn.net/zhourenfei17/article/details/83543002
https://blog.csdn.net/qq_20954959/article/details/55260255

9. 目前ShiroConfig里面shiro的认证缓存是设置为了false,因为如果缓存了，那现在的签友汇，渠道版本的修改账号的修改密码功能就会有影响
	解决办法，要么采用合同项目中的缓存方案，要么自己再找别的方案
	几个缓存属性，要设置为一致的，都为true，或者都为false才没有问题
10.

*****
选择Log4j2的理由是啥，为啥不用spring boot 默认的？
在Log4j 1.x中同步写日志的时候，在高并发情况下出现死锁导致cpu使用率异常飙升。其中的原因是当一个进程写日志的时候需要获取到Logger和Appender

##如果要细分为，分别为平台日志、 业务日志、错误日志、DB日志，则根据下面的文档来：
https://blog.csdn.net/u010598111/article/details/80556437
https://blog.csdn.net/ahou2468/article/details/80486409 这个文章非常好

log4j2参数详细配置说明文档：https://blog.csdn.net/fz13768884254/article/details/81214773


# crm

运行环境：
	MyEclipse直接导出crm为 crm.war包，发布至tomcat/wepapps目录即可.
	apache-tomcat-8.0.14  + JDK8  本地测试都使用32位软件测试通过.

发布的swagger接口访问地址：
	http://localhost:8080/crm/swagger-ui.html 

druid控制台进入界面
http://localhost:8080/crm/druid/login.html  账号：admin  admin
	
项目目录结构如下(com.esa2000):
1. business 业务模块
    - bean 非数据库实体类 BEAN
    - constants 常量
    - entity 数据库对应 BEAN
    - enums 枚举值
    - mapper 数据库接口定义
    - service 数据库操作
    - utils 工具类
    - web 控制类
2. configs 配置模块
    - exception 异常配置
    - interceptor 
    - shiro
    - timer 定时器
3. swagger2 测试接口模块: 放测试接口类, 只在生产环境和测试环境生效
	(2.9.2这个版本有bug，不要在pom.xml里面引入，首页会出不来)
	汉化文件目录：src/main/resources/META-INF/resources/
	汉化参考：https://www.jianshu.com/p/7e543f0f0bd8  我没有去修改zh.cn.js文件了，貌似Request Headers这个汉化不起作用，有时间再研究吧
	隐藏顶栏参考：https://blog.csdn.net/yanxilou/article/details/82839108
	swagger接口参数用法说明：https://blog.csdn.net/xudant/article/details/82856555
	返回的全部有注释：https://blog.51cto.com/5634409/2343942?source=dra   需要改造我的Result类
	
	***其实汉化，不用参考网上的文档了，直接解压springfox-swagger-ui.jar包，找到swagger-ui.html文件，在这个文件中引入中文支持即可
	<script src='webjars/springfox-swagger-ui/lang/translator.js' type='text/javascript'></script>
  	<script src='webjars/springfox-swagger-ui/lang/zh-cn.js' type='text/javascript'></script>
  	使用这种方式，还可以避免网上的文档使用的swagger版本跟你的版本不一致，汉化还失效的情况
  	
  	集成2.9.2版本,  2.9.2版本是2018年6月更新的，现在都快1年了还没更新
  	https://blog.csdn.net/allen_lu_hh/article/details/83218028
  	说明：
	此版本已经集成swagger2.9.2版本，外观很不一样，而且没有汉化,网上的汉化存在一些问题
	最主要的是json传参未实现，自己使用swagger的api在control层的方法上，只要有声明就会报空指针异常
	
	怀疑
	https://www.jianshu.com/p/fe58f7457e38  重点看这个，这个还有github代码下载
	https://blog.csdn.net/hellopeng1/article/details/82227942
	https://github.com/cyjishuang/swagger-mode
	写得的这些文章有问题
	
	从上面的文章上的效果看：他也是使用了swagger2.9.2才可以实现json传参
	
	springfox-swagger版本更新列表
	https://mvnrepository.com/artifact/io.springfox

4.  MyEclipse spring boot配置热部署  https://blog.csdn.net/qq_34178998/article/details/79158076，配了这个容易出现问题，
	原因就是shiro的原因，不集成shiro，热部署没有问题，集成shiro也可以热部署，不过要改一些麻烦的东西

5.  mybatils plus使用心得：
    <select id="getTop100" resultMap="getTop100VipMap">  像这种写法是自己定义一个resultMap来匹配定义的sql查询的返回结集
    <resultMap id="getTop100VipMap" type="java.util.LinkedHashMap">
		<result column="num" property="num" />
		<result column="vip_id" property="vipId" />
		<result column="vip_type" property="vipType" />
		<result column="push_money_count" property="pushMoneyCount" />
	</resultMap>
	
	如果没有定义resultMap的话，那么会自动返回数据库中查询出来的原生的列名，即会显示成  vip_id  vip_type，你这个resultMap里面定义的列与你的sql查出来的列不
	匹配都没事，所以我又升级做法，定义一个空的map来满足大批量的自定义sql返回map结果集的做法
	<resultMap id="defaultMap" type="java.util.LinkedHashMap">
    </resultMap>
    	这种是有序的返回写法，也可以使用默认的java.util.HashMap这样这个defaultMap都不用定义
    
    记得写别名，如as c，不写别名，直接使用select c.*会报错
    select c.* from sys_user as a, crm_user_customer as b, crm_customer as c 
			where a.id=b.user_id and b.customer_id=c.id	 and a.id=#{userId}
			<if test="customerType !=null and customerType !='null' and customerType !=''">
				and b.customer_type=#{customerType}
			</if>
			<if test="customerGroupTypeId !=null and customerGroupTypeId !='null' and customerGroupTypeId !=''">
				and b.customer_group_type_id=#{customerGroupTypeId}
			</if>
			limit #{startRow}, #{pageSize}

6. 注意：需要控制事务的方法，在serviceImpl层，一定要将方法定义为：throws Exception，你如果异常不抛出，
	那事务肯定不会回滚了，因为框架都不知道你有抛出异常，因为你自己捕获处理了
	
	在这个服务层的实现类的方法中，不能再引入任何的服务层方法来操作增删改，否则事务会失效，服务层的方法里面，引入别的Mapper层即可
	如：
	if(userOrgService.saveBatch(userOrgList)){  通过在服务实现层中注入userOrgService服务，写到这个事务控制的方法体中，此方法的事务将失效
	//有事务不能再引入其他的服务层
	
7. -- 修改mysql数据库配置文件/etc/mysql/my.cnf  只有改下面的才可以支持emoji表情,确保mysql版本5.5.3以上才行，我的连接mysql的url为：
-- url: jdbc:mysql://localhost:3306/crm，不需要像网上写的在这个crm后面再追加什么编码之类的
-- 增加如下内容（以支持emoji表情字符）：
-- character-set-client-handshake=FALSE
-- character-set-server=utf8mb4
-- collation-server=utf8mb4_unicode_ci 

8. 全局时间格式解决方案 ：
	 yyyy-MM-DD  HH:mm:ss   目前我配的这个类LocalDateTimeFormatConfig 就是为了解决 LocalDateTime时间问题的，
	没这个类之前，返回给前端的时间类型中间会有一个T,如：2018-06-14T15:06:05
	可参考：https://www.cnblogs.com/carrychan/p/9883172.html

9. mysql详细的数据类型说明：  https://www.cnblogs.com/-xlp/p/8617760.html

10. 做系统的关键操作的日志功能，使用注解实现，我比较推荐使用这种，但目前的方法参数，都是一个一个的，没有使用Json对象的请求入参，不好改造了
	下面是使用AOP使用注解实现
	https://blog.csdn.net/zyjcxc/article/details/80360135
	
11. mysql自定义排序规则，分页出现重复数据问题
	https://www.cnblogs.com/glon/p/6806064.html
	可以查看VipMapper.xml中  order by field(id_verify,'2','7','5','6','4','1','0') asc,id 增加这个id即可解决

12.注意：
	权限注解加到control层，事务注解加到server层，因为server层已经控制事务，这一层其实已经是一个代理了，你不能让权限注解使用server层，即代理的代理，这样容易出现类型转换异常
	所以最好分开，权限注解加到control层，事务注解加到server层，需要用到事务的，就写到server层去
	本来Mybatils plus支持 AR功能，可以直接把service层都可以去掉的，但为了全局整体控制事务，还是需要这个service层的，貌似这种AOP只能针对接口层，面向接口层才可以进行动态代理
	没时间仔细研究了，，，在不需要事务控制的地方，比如写权限控制类，查询菜单列表的地方，可以使用AR实体类进行查询列表的功能，也很方便
	所以要用到事务的，还是不要使用AR功能，随便到处写增删改查
	
13.  //跳转到test.html
	return "redirect:/testThymeleaf";  这样就是请求路径，这就是重定向到另一个请求，重定向消息就带不过去
	return "testThymeleaf";  这样就是请求页面
	
14. 我们建的项目是一个java项目，是没有webapp目录的，我们要把所有的页面放在
	templates下面 ，templates目录是一个固定的写法，把这个目录当作web应用的根目录
	
15. springboot无论是java项目还是web项目，在maven建工程的时候，统统以jar方式打包运行

16. springboot 静态方法注入bean
springboot项目中 bean类 无法使用@Autowired注入sevice,需要手动初始化，初始化后才可使用

其实代码不是下面这样写，把这个工具类定义为一个接口即可，这种需要跟数据库打交道的工具类，就应该定义为一个接口层，这样就不用手动初始化了，可以直接注入，在使用这个工具类的
时候，也不用使用new Utils() 这种写法了，可以 直接@Autowired注入这个工具类就可以使用

		@Component 
		public class Utils { 
		@Autowired 
		private Service service; 
		private static Utils utils; 
		public void setUserInfo(Service service) { 
		this.service = service; 
		} 
		//初始化静态参数
		@PostConstruct 
		public void init() { 
		　　utils = this; 
		　　utils.service = this.service; 
		} 
		 
		public static void insertOpeLog(HttpServletRequest req, String str) { 
		 
		　　ServiceBean bean =new ServiceBean();
		　　utils.service.save(bean); //调用方法} 
		}
		
	或者采用下面的方案，也是目前我采用的方案，上面的太麻烦还需要去新建工具类，还需要去初始化化，太麻烦

在接口的实现层标上	@Service注解，
@Service
public class NodeServiceImpl implements NodeService{
在使用的地方，这样使用 NodeService nodeService = SpringUtil.getBean(NodeServiceImpl.class); 这种方式，
	自动生成的service层，因为继承了mybatils plus框架的IService，所以不用我们处理,
上面的说法全是错误的，正确方式
********************
//		NodeService nodeService = SpringUtil.getBean(NodeServiceImpl.class);  错误用法
问题的关键在于自定义的Service层对应的Impl实现层的类上面需要有@Service注解，有加这个注解，就可以在Controller层，
	以及其他的serviceImpl层使用@Autowired
	NodeService nodeService;注入使用了
	
@Service
public class NodeServiceImpl implements NodeService{

17.  myeclipse设置类注释：   选择设置java-->Code Style-->Code Templates-->Comments--> Types 输入下面的内容
/**
 * @author xiechao
 * @date ${date} ${time}
 * @Descripton
 */
 同时勾上Automatically add Comment 新建类时就会自动带上注释了

18. 采用String.valueOf不会报空指针问题
	System.out.println("params参数为：" + params);
			
			JSONObject jsonObject = JSON.parseObject(params);
			String orgId = String.valueOf(jsonObject.get("orgId"));
			String pageNum = String.valueOf(jsonObject.get("pageNum"));
			String pageSize = String.valueOf(jsonObject.get("pageSize"));
			String name = String.valueOf(jsonObject.get("name"));
			String loginName = String.valueOf(jsonObject.get("loginName"));
			
			StringUtil.validateIsNull(orgId, "请输入机构ID");
			StringUtil.validateIsNull(pageNum, "请输入页码");
			StringUtil.validateIsNull(pageSize, "请输入每页记录数");
			
19. <!-- 不要采用or，会出问题，使用union，本身就有数据去重的功能 -->
select * from (
			select a.* from sys_user as a, sys_user_org as b where a.id=b.user_id and b.org_id=#{orgId}
			<if test="name !=null and name !='null' and name !=''">
				and a.user_name like '%${name}%' or a.login_name like '%${name}%'
			</if>
		union
		select a.* from sys_user as a, sys_user_org as b where a.id=b.user_id and b.org_id=#{orgId}
			<if test="name !=null and name !='null' and name !=''">
				a.login_name like '%${name}%'
			</if>
			) as temp
		limit #{startRow}, #{pageSize}
		
20. mybatis在xml文件中传参时会自动在将传入的参数使用 单引号括起来，''，如果不希望括起来，则使用下面的方式：
	and customer_group_tag_type_id in (${customerTagListStr}) 这种有注入风险，谨慎使用，需要对入参做严格的强校验
	
	如果使用in的写法，那么这个参数要封装在map里面，或者在Mapper层定义方法使用
	public Integer getBranchCustomerCount(@Param("branchOrgId")String branchOrgId);
//	public Integer getBranchCustomerCount(Map<Object, Object> map);

	<select id="getBranchCustomerCount" resultType="Integer"  parameterType="java.util.Map">
		select count(*) from crm_branch_org_customer where branch_org_id in (${branchOrgId})
		<!-- select count(*) from crm_branch_org_customer where branch_org_id=#{branchOrgId} 等号的话，就不需要使用@Param("branchOrgId")去声明变量 -->
	</select>
	
	这个返回数量可以是Integer  Long  Double(将带小数点)  BigDecimal（这个最好，是多少数量就是多少，没有默认加上小数点，如果有小数点，就有小数点，没有默认不会加上小数点，而且返回的这个类型还可以直接使用我的工具类进行计算）
	<select id="getBranchCustomerCount" resultType="BigDecimal"  parameterType="String">
		select count(*) from crm_branch_org_customer where branch_org_id in (${branchOrgId})
		<!-- select count(*) from crm_branch_org_customer where branch_org_id=#{branchOrgId} -->
	</select>

21. mysql递归查询（子查询）
	https://www.cnblogs.com/rainydayfmb/p/8028868.html
	
	select id from (
              select t1.id,
              if(find_in_set(parent_id, @pids) > 0, @pids := concat(@pids, ',', id), 0) as ischild
              from (
                   select id,parent_id from re_menu t where t.status = 1 order by parent_id, id
                  ) t1,
                  (select @pids := 要查询的菜单节点 id) t2
             ) t3 where ischild != 0
             
     我改后使用的：
     select * from (
              select t1.*,
              if(find_in_set(parent_id, @pids) > 0, @pids := concat(@pids, ',', id), 0) as ischild
              from (
                   select * from sys_org t order by parent_id, id  -- 注意这里一定要有两个，否则展现的结果将没有子结果,可以利用这个特性来做，只加载下一级菜单，只加载下一级就不要这样做了，直接使用parent_id查这个表，一个普通的select * from where parent_id=''就行了
                  ) t1,
                  (select @pids := 2) t2
             ) t3 where ischild != 0
             
      select  c.user_name as delete_user_name,d.id,d.customer_name,d.sex,d.customer_source_type,d.customer_source_name,d.customer_source_name_value,d.customer_group_type_id,
							d.customer_stage,d.weixin_id,d.qq,d.mobile,d.phone,d.email,
							date_format(d.create_time,'%Y-%m-%d %H:%s:%s') as create_time,
							date_format(d.update_time,'%Y-%m-%d %H:%s:%s') as update_time,
							date_format(d.recent_dynamic_date_time,'%Y-%m-%d %H:%s:%s') as recent_dynamic_date_time,
							date_format(d.delete_date_time,'%Y-%m-%d %H:%s:%s') as delete_date_time,
							d.province_id,d.province_name,d.city_id,d.city_name,d.area_id,d.area_name,d.company_name,d.address,d.job_age,d.education,
							d.professional,d.customer_activity_page,d.customer_activity_type_page,d.create_user_id,d.follow_user_id,d.delete_user_id,
							d.sea_type,d.state,d.remark2,d.yijiankemu2,d.banxingmingcheng2,d.remark,d.delete_cause_id,d.delete_cause,
							d.transfer_cause_id,d.transfer_cause,d.waive_cause_id,d.waive_cause,d.recent_dynamic_content,d.import_batch_no
				    from
				    	sys_org as a, sys_user_org as b, sys_user as c, crm_customer as d
					where 
							a.id=b.org_id and b.user_id=c.id  and c.id=d.follow_user_id
							and d.state='1' and a.org_type!='4' and a.id
							 in (
								select t3.id from (
				              		select t1.*,
				            		  if(find_in_set(parent_id, @pids) > 0, @pids := concat(@pids, ',', id), 0) as ischild
				             			 from (
				                 			  select * from sys_org t where 1=1 order by parent_id, id
				                 			 ) t1,
				               			   (select @pids := #{orgId}) t2
				            		 ) t3 where ischild != 0
								)
             
22.   mybatils plus或者mybatils的selectOne方法，都可以在后面加上 limit 1来防止程序或接口报错
		例如：return userMapper.selectOne(new QueryWrapper<UserEntity>().eq("login_name", loginName).last("limit 1"));
		
23.  消息推送技术，下面几个按顺序观看
https://blog.csdn.net/hry2015/article/details/79545157
https://blog.csdn.net/hry2015/article/details/79829616
https://blog.csdn.net/hry2015/article/details/79838194
https://blog.csdn.net/hry2015/article/details/81123549
https://blog.csdn.net/hry2015/article/details/81226155------
https://blog.csdn.net/hry2015/article/details/81290941------  我是使用这个搭建起来的
https://www.cnblogs.com/xifengxiaoma/p/11121355.html----  rabbitMQ写得最详细的文章了
https://www.cnblogs.com/toov5/p/10289999.html-------------rabbitMQ相当重要的思想
https://blog.csdn.net/weixin_44048532/article/details/86628234
https://www.cnblogs.com/wuhenzhidu/p/10800239.html  RabbitMQ指南之三：发布/订阅模式（Publish/Subscribe）---必需看明白

		https://blog.csdn.net/moshowgame/article/details/80275084   这个写得非常详细
		https://blog.csdn.net/ifrozen/article/details/79972657 集群问题
	
kafka技术，事务
https://www.cnblogs.com/middleware/p/9477133.html
https://ke.qq.com/course/460130?taid=4733741155419490 视频教程

		
		https://www.cnblogs.com/gxp69/p/11736749.html   websocket会自动断开的问题
		
		http://www.websocket-test.com/
		https://www.cnblogs.com/best/p/5695570.html#_lab2_6_0
		https://www.runoob.com/html/html5-websocket.html   websocket技术，来做推送
		https://blog.csdn.net/qq_39470742/article/details/83411912  websocket集群的问题，提到了rabbitmq
		
rabbitMQ介绍得详细
https://blog.csdn.net/weixin_43617082/article/details/83780700

消费幂等性,即要保证消息不会被重复消费

24. java集合实现堆栈，没有问题
		Java 集合ArrayList与Vector的详解  
		https://blog.csdn.net/qq_33642117/article/details/51998866
		
25. 多文件上传使用postMan测试，swagger不支持多文件数组上传
	swagger只能测试单文件上传
	如果是文件数组 就会传递空值，这和接口没有什么关系，多文件上传接口可以用 postMan 工具测试
	@PostMapping(value="/imgStrList",consumes="multipart/*",headers="content-type=multipart/form-data")
	public Result imgStrList(@RequestParam("fileArray")MultipartFile fileArray){
	
	}
	https://blog.csdn.net/qq_29881093/article/details/89526442
	
	https://blog.csdn.net/persistencegoing/article/details/87892640  根据这个使用postMan可以调通，在postMan的文件框，一次选择多个文件即可，会显示你有多少个文件被选中
	
26.  Java 多用户登录限制的实现方法
		https://www.jb51.net/article/96755.htm

27. echartsjs做报表，做前后端分离，很方便

28.   一张图看懂比特币、以太坊、联盟链等区块链系统架构
	https://baijiahao.baidu.com/s?id=1626722232547841026&wfr=spider&for=pc
	
	还有EOS  以太坊
	
29. springboot定时任务，需要考虑集群问题
	********************动态定时任务
	https://www.cnblogs.com/laoyeye/p/9352002.html 动态定时任务（参考这个即可）
	https://blog.csdn.net/qq_26440803/article/details/83066238    定时任务集群（加上上一行，这两个文章共同使用）

	https://www.jianshu.com/p/30c1fb5f7f04   参考这个，开发的时候就要注意集群环境的问题，确保只有一台服务器执行此定时任务
	https://www.cnblogs.com/mmzs/p/10161936.html  多线程定时任务也有说明，可数据库加载指定时间
	
	http://qqe2.com/cron/index  cron 在线生成
	但是，这种方式有一个缺点就是，将数据库cron字段值设为null或者“”以及不正确的值，这样定时任务就会停止执行，这样就算你下一次再给cron字段添加了正确的值，项目也不会执行定时任务了，这个时候就需要重新启动项目才行。
	
	***我目前根据端口号判断只允许有一台机器执行定时任务，如果要考虑单点故障问题可以在我现在写的基础上再扩展为：如果当前指定端口的机器是挂掉的状态，则使用备用节点来执行定时任务
	
30. nginx技术：  正向代理：代理的是客户端，如VPN     反向代理：代理的是服务器,如域名映射
	https://juejin.im/post/5bd7a6046fb9a05d2c43f8c7#heading-8
	
	在Java设计模式中，代理模式是这样定义的：给某个对象提供一个代理对象，并由代理对象控制原对象的引用。
	
	https://www.cnblogs.com/ysocean/p/9392908.html
　　可能大家不太明白这句话，在举一个现实生活中的例子：比如我们要买一间二手房，虽然我们可以自己去找房源，但是这太花费时间精力了，
	而且房屋质量检测以及房屋过户等一系列手续也都得我们去办，再说现在这个社会，等我们找到房源，说不定房子都已经涨价了，那么怎么办呢？
	最简单快捷的方法就是找二手房中介公司（为什么？别人那里房源多啊），于是我们就委托中介公司来给我找合适的房子，以及后续的质量检测过户等操作，
	我们只需要选好自己想要的房子，然后交钱就行了。


31. springCloud的单点登录，讲得很详细 
	https://www.cnblogs.com/xifengxiaoma/p/10043173.html
	
32. 
	JSON.stringify() json序列化，可以将json对象中键值对都加上双引号，
	var sendJson = {
							"command":"UploadFile",
							"arguments":{
								"url":url,
								"file":result.recordpath,
								"diykey":"userId,answerTime,callNumber,callState,callType,customerId,endTime,startTime",
								"diyvalue":self.userObj.id+","+self.socketRecordObject.answertime+","+self.socketTelNumber+","+self.socketRecordObject.state+","+1+","+self.socketCustomerId+","+self.socketRecordObject.endtime+","+self.socketRecordObject.starttime
							},
						};
		var sendJson = JSON.stringify(sendObject);
		webSocket.send(sendJson);
		以上就是那个亿维厂家，只能解析这种json产生的问题
		
33.	json操作
		JsonArray array=new JsonArray();
		JsonObject lan1=new JsonObject();

		lan1.addProperty("id", 1);
		lan1.addProperty("name", "Java");
		lan1.addProperty("ide", "Eclipse");

		//将 lan1 添加到 array
		array.add(lan1);
		
		System.out.println(array);//打印json数组
		System.out.println(lan1);//打印json对象
	
34.  oauth2.0说得很详细，比喻也很抽象
	http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html  其实就是将自己应用，开放给第三方应用授权使用，但没有将用户密码给第三方，典型的就是
														微信，QQ在其他地方登录，不过比如手机安装了淘宝，那么再安装支付宝，也不用输入密码，也可以使用淘宝APP登录
														应该不仅仅是不同的公司间的产品，同一个公司间的产品也可以使用ouah方式来做
	
	jwt（JSON Web Token）方案，讲得很详细
	https://baijiahao.baidu.com/s?id=1608021814182894637&wfr=spider&for=pc
	JWT的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权限。也就是说，一旦JWT签发，在有效期内将会一直有效。
	也有办法补救啊，在发生权限变更的时候，清除会话，让别人重新登录，不就完了，令牌的权限也可以更改，刷新一下缓存也可以
	
	集成oauth
	https://www.cnblogs.com/xifengxiaoma/p/11106220.html  Spring Boot：整合Spring Security
	https://www.cnblogs.com/xifengxiaoma/p/10043173.html   Spring Security Oauth2 单点登录案例实现和执行流程剖析
	https://www.cnblogs.com/xifengxiaoma/p/9987278.html Spring Boot + Spring Cloud 实现权限管理系统 后端篇（二十五）：Spring Security 版本
	
	JWT的用法:
		客户端接收服务器返回的JWT，将其存储在Cookie或localStorage中。
		此后，客户端将在与服务器交互中都会带JWT。如果将它存储在Cookie中，就可以自动发送，但是不会跨域，因此一般是将它放入HTTP请求的Header Authorization字段中。
		Authorization: Bearer
		当跨域时，也可以将JWT被放置于POST请求的数据主体中
	
	
35. 分步式文件系统，收费的，就直接使用阿里云应该是最快速的，自己建就使用crph这个吧，虽然目前不是很成熟，小红帽都移除对他的支持，不知道后面会不会再增加回来
	HDFS这个是hadoop体系的
	
	FastDFS,这个是最轻量级的
	---------------------------------------
	是一款类似Google FS的开源分布式文件系统，是纯C语言开发的。
	FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。
	官方论坛  http://bbs.chinaunix.net/forum-240-1.html
	FastDfs google Code     http://code.google.com/p/fastdfs/
	分布式文件系统FastDFS架构剖析   http://www.programmer.com.cn/4380/
	
	hadoop是一个分布式的计算框架，主要用于分布式的存储（HDFS）和计算（MapReduce，可以被Spark替代），其机器间的技术使用的RPC（RPC可以使用HTTP协议实现，
	也可以是基于SOCKET自己定义新的协议）。其通俗的解释是将一个计算同时分派到很多机器一起算，每个机器算一部分。

	springcloud和dubbo都是分布式的服务框架，主要承担分布式服务器间的RPC通信功能。springcloud的通信协议是REST，dubbo的通信技术是RPC。
	其通俗的解释是一个程序的不同模块放在了不同机器上，所以他们之间需要用网线来连在一起交互。

	zookeeper是一个服务治理的组件，一般用于和dubbo配合使用（springcloud一般和eureka配合），因为dubbo实现了通信功能，
	但是你如果需要多个机器相应同一个功能模块，就需要 zookeeper来进行调度看什么时候分给哪一个。
	
	Springcloud集成hadoop HDFS，使用Feign-form实现文件上传、下载
	https://blog.csdn.net/qq_41780231/article/details/101452487
	
	linux搭建分布式文件系统FastDFS并整合spring boot
	https://blog.csdn.net/xcg132566/article/details/79163790
	
	优点
	1）系统无需支持POSIX(可移植操作系统)，降低了系统的复杂度，处理效率更高
	2）支持在线扩容机制，增强系统的可扩展性
	3）实现了软RAID，增强系统的并发处理能力及数据容错恢复能力
	4）支持主从文件，支持自定义扩展名
	5）主备Tracker服务，增强系统的可用性

	缺点：
		1）不支持断点续传，对大文件将是噩梦(FastDFS不适合大文件存储)
		2）不支持POSIX通用接口访问，通用性较低
		3）对跨公网的文件同步，存在较大延迟，需要应用做相应的容错策略
		4）同步机制不支持文件正确性校验，降低了系统的可用性
		5）通过API下载，存在单点的性能瓶颈


36.  git是分布式的版本管理工具，svn是集中式的版本管理工具
	SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，
	需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。

	Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。
	既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，
	就可以互相看到对方的修改了。

37. 
	主从，哨兵，集群，下面这个讲得非常详细
	https://blog.csdn.net/miss1181248983/article/details/90056960
	
	redis 主从模式，哨兵模式，cluster(集群)模式 简介
	https://blog.csdn.net/qq_28410283/article/details/89197156
	
	主从模式:是三种集群方式里最简单的。它主要是基于Redis的主从复制特性架构的。通常我们会设置一个主节点，N个从节点;默认情况下，主节点负责处理使用者的IO操作，而从节点则会对主节点的数据进行备份，并且也会对外提供读操作的处理
	
	哨兵模式：是基于主从模式做的一定变化，它能够为Redis提供了高可用性。在实际生产中，服务器难免不会遇到一些突发状况：服务器宕机，停电，硬件损坏等。这些情况一旦发生，其后果往往是不可估量的。而哨兵模式在一定程度上能够帮我们规避掉这些意外导致的灾难性后果。其实，哨兵模式的核心还是主从复制。只不过相对于主从模式在主节点宕机导致不可写的情况下，多了一个竞选机制——从所有的从节点竞选出新的主节点。竞选机制的实现，是依赖于在系统中启动一个sentinel进程。
	
	Redis集群（cluster） Redis 集群是一个提供在多个Redis间节点间共享数据的程序集。

	Redis集群并不支持处理多个keys的命令,因为这需要在不同的节点间移动数据,从而达不到像Redis那样的性能,在高负载的情况下可能会导致不可预料的错误.
	
	Redis 集群通过分区来提供一定程度的可用性,在实际环境中当某个节点宕机或者不可达的情况下继续处理命令. Redis 集群的优势:
	
	自动分割数据到不同的节点上。
	
	整个集群的部分节点失败或者不可达的情况下能够继续处理命令。
	
	
	sentinel模式基本可以满足一般生产的需求，具备高可用性。但是当数据量过大到一台服务器存放不下的情况时，主从模式或sentinel模式就不能满足需求了，这个时候需要对存储的数据进行分片，将数据存储到多个Redis实例中。cluster模式的出现就是为了解决单机Redis容量有限的问题，将Redis的数据根据一定的规则分配到多台机器。

cluster可以说是sentinel和主从模式的结合体，通过cluster可以实现主从和master重选功能，所以如果配置两个副本三个分片的话，就需要六个Redis实例。因为Redis的数据是根据一定规则分配到cluster的不同机器的，当数据量过大时，可以新增机器进行扩容。

使用集群，只需要将redis配置文件中的cluster-enable配置打开即可。每个集群中至少需要三个主数据库才能正常运行，新增节点非常方便。


38.  docker这个必需看
	https://blog.csdn.net/deng624796905/article/details/86493330
	
39.  servlet生命周期
	1.客户端请求该 Servlet；
	2.加载 Servlet 类到内存；
	3.实例化并调用init()方法初始化该 Servlet；
	4.service()（根据请求方法不同调用doGet() 或者 doPost()，此外还有doHead()、doPut()、doTrace()、doDelete()、doOptions()、destroy())。
	5.加载和实例化 Servlet。这项操作一般是动态执行的。然而，Server 通常会提供一个管理的选项，用于在 Server 启动时强制装载和初始化特定的 Servlet。
	6.销毁
	
40. 敏捷开发：
	敏捷方法有时候被误认为是无计划性和纪律性的方法，实际上更确切的说法是敏捷方法强调适应性而非预见性。
	适应性的方法集中在快速适应现实的变化。当项目的需求起了变化，团队应该迅速适应。这个团队可能很难确切描述未来将会如何变化.
	对比迭代方法
	相比迭代式开发两者都强调在较短的开发周期提交软件，敏捷方法的周期可能更短，并且更加强调队伍中的高度协作。
	对比瀑布式开发
	两者没有很多的共同点，瀑布模型式是最典型的预见性的方法，严格遵循预先计划的需求、分析、设计、编码、测试的步骤顺序进行。步骤成果作为衡量进度的方法，例如需求规格，设计文档，测试计划和代码审阅等等。
	瀑布式的主要的问题是它的严格分级导致的自由度降低，项目早期即作出承诺导致对后期需求的变化难以调整，代价高昂。瀑布式方法在需求不明并且在项目进行过程中可能变化的情况下基本是不可行的。

41. 
	Spring Cloud Security 之 JWT
	https://www.cnblogs.com/moues/p/10826845.html
	
42.
	基于 Token 的身份认证 与 基于服务器的身份认证
　　1、基于服务器的身份认证
　　　　传统的做法是将已经认证过的用户信息存储在服务器上，比如Session。用户下次请求的时候带着Session ID，然后服务器以此检查用户是否认证过。
　　　　存在如下问题：
　　　　a、session存储内存，用户过多，消耗内存　　
　　　　b、session共享问题
　　　　c、跨域请求授权问题
　　　　d、容易遭受CSRF攻击

　　2、JWT 与 session 的差异
　　　　a、session 存储在服务器，JWT保存在客户端，JWT更利于减轻服务端内存压力
　　　　b、JWT是无状态的，可以解决 用户信息 共享问题
　　　　c、JWT是加密字符串，更加安全，有助于防止CSRF攻击

　　3、JWT 与 OAuth 的区别
　　　　a、OAuth2 是一种授权框架，JWT 是一种认证协议
　　　　b、无论使用哪种方式切记用HTTPS来保证数据的安全性

OAuth2在“客户端”与“服务提供商”之间，设置了一个授权层(authorization layer)。“客户端”不能直接登录“服务提供商”，只能登录授权层，以此将用户与客户端分离。

43.   
	/* 如果后台的control类，定义路径如：@RequestMapping(value = "/ws")
 * 那么前端引入static目录下的文件，就是如下的引用：
 * <script th:src="@{/js/jquery.js}"></script>
 * <!-- <script src="/crm/js/jquery.js"></script>
 * 如果没有定义路径，则就是默认的路径：
 * <script src="js/stomp.js"></script>
 * 
 * 前端如果使用了 <script th:src="@{/js/jquery.js}"></script> 这个模板标签，就会自动在后面加上jsessionId，如下：
 * http://localhost:8080/crm/js/sockjs.js;JSESSIONID=f2d903b8-8485-4fa3-b95d-f5301ee374f7   
 * 不过现在都是前后端分离，不会使用这个模板技术来做前端了，所以下面这个代码解决后面自动带上jsessionid的问题不用处理，其实引入下面这个也没有生效也解决不了
 * public void onStartup(ServletContext servletContext)throws ServletException {
        super.onStartup(servletContext);
        servletContext.setSessionTrackingModes(Collections.singleton(SessionTrackingMode.COOKIE));
        SessionCookieConfig sessionCookieConfig = servletContext.getSessionCookieConfig();
        sessionCookieConfig.setHttpOnly(true);
    }*/

44. 
	https://www.cnblogs.com/goodshred/p/9882764.html   java箭头函数，lambda表达式
	// 1. 不需要参数,返回值为 5  
	() -> 5  
	  
	// 2. 接收一个参数(数字类型),返回其2倍的值  
	x -> 2 * x  
	  
	// 3. 接受2个参数(数字),并返回他们的差值  
	(x, y) -> x – y  
	  
	// 4. 接收2个int型整数,返回他们的和  
	(int x, int y) -> x + y  
	  
	// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  
	(String s) -> System.out.print(s)

45. GitHub 和  GitLab 都是基于 web 的 Git 仓库，使用起来二者差不多，它们都提供了分享开源项目的平台，
	为开发团队提供了存储、分享、发布和合作开发项目的中心化云存储的场所。
	GitHub 作为开源代码库，拥有超过 900 万的开发者用户，目前仍然是最火的开源项目托管平台，GitHub 同时
	提供公共仓库和私有仓库，但如果使用私有仓库，是需要付费的。
	GitLab 解决了这个问题，你可以在上面创建私人的免费仓库。


46. 数据库表，mysql定义下面的类型，则java中对应的为布尔类型，利用这个特性，虽然在java代码里面可以用true,false，但自定义sql的时候，又回到0，1的硬编码了
 `is_parent` tinyint(1) NOT NULL COMMENT '是否为父节点，0为否，1为是',
  `letter` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '品牌的首字母',
  
  方法定义还是要这样写，结合swagger在上面再定义一下这些参数的列表说明即可，原来那种改swagger源码的方式，还是不可取，
  你看下面，参数的默认类型，默认值都可以指定，比如Integer，就传这种类型进来，我也不用到处转换了，
  也不用考虑新增哪种用户，或者商品参数过多的问题，像这种接口，就新增，修改参数过多一点，其他接口参数又不多，改swagger源码也要淘汰了
  @GetMapping("page")
    public ResponseEntity<PageResult<Brand>> queryBrandByPage(@RequestParam(value = "page", defaultValue = "1") Integer page,
                                                              @RequestParam(value = "rows", defaultValue = "5") Integer rows,
                                                              @RequestParam(value = "sortBy", required = false) String sortBy,
                                                              @RequestParam(value = "desc", defaultValue = "false") Boolean desc,
                                                              @RequestParam(value = "key", required = false) String key){
        BrandQueryByPageParameter brandQueryByPageParameter=new BrandQueryByPageParameter(page,rows,sortBy,desc,key);
        PageResult<Brand> result = this.brandService.queryBrandByPage(brandQueryByPageParameter);
        if(result == null){
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
        }
        return ResponseEntity.ok(result);
    }
也不一定所有的方法都要定义成post了，这样写代码显得很不专业，像这些分页查询什么，都可以定义为get即可

ajax请求才会出现跨域

47. 以后判空的操作，都使用StringUtils.isBlank();
	StringUtils.isEmpty()，注意这两个有点区别
	
	比如截取一个文件的后缀名，是不是String.subString这是不是比较low啊
	字符串处理，你应该首先想到StringUtils
	StrinUtils.substringAfterLast();
	我们使用Content-type来判断文件类型  
	
	logger.info("文件类型不合法：" + oriinalFilename);//这种写法是不是有点low啊，还要去拼寡不敌众串
	logger.info("文件类型不合法：{}",oriinalFilename); //这种写法的好处，可以使用多个占位符

文件上传，可以使用nginx代理到图片路径：
修改nginx.conf配置文件
server {
        listen       80;
        server_name  image.leyou.com;

        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Server $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        location / {
			root: G:\\LeYou\\upload;  代理到这个路径
        }
    }
然后在浏览器上可以:http://image.leyou.com/xxx.jpg  
那么只要放在G:\\LeYou\\upload路径下的文件，就可以通过敲地址栏进行访问了

我们要想办法，让图片上传这些绕过网关，减轻网关的压力，因为文件操作，非常占用资源
绕过网关，有两种思路，一种是在网关里面配置，让网关忽略一些/upload路径或者忽略upload-server微服务，但是这两种配置方法
都不可取，这样还是经过网关了，我们应该直接在nginx里面配置

配置如下:
server {
        listen       80;
        server_name  image.leyou.com;

        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Server $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        location /api/upload {
			proxy_pass http://127.0.0.1:8082;
			proxy_connect_timeout 600;
			proxy_read_timeout 600;
        }
        location / {
			proxy_pass http://127.0.0.1:10010;
			proxy_connect_timeout 600;
			proxy_read_timeout 600;
        }
    }

location /api/upload {
location / {
注意这两个的顺序，不能颠倒，一定是先判断路径是否是服务器路径，如果是则路由到文件上传微服务，否则路由到10010


50. 
List<OrgEntity> tempOrgList = new ArrayList<>();
Set<OrgEntity> orgSetList = new HashSet<OrgEntity>();
List<OrgEntity> orgList = new ArrayList<OrgEntity>();
	orgSetList.addAll(orgList);//这里将list集合添加至set集合，那么重复的数据就没有了
	
findChildren(tempOrgList, new ArrayList<OrgEntity>(orgSetList));//这里又将orgSetList集合转为list集合



51.	参数再也不要像下面这样写了
@ApiJsonObject(name = "getFollowUserList", value = { 
			@ApiJsonProperty(name = UserJson.userName),//这些不要再使用了
			@ApiJsonProperty(name = GlobalJson.pageNum),//这些不要再使用了
			@ApiJsonProperty(name = GlobalJson.pageSize)})//这些不要再使用了
	@ApiImplicitParam(name = "params", required = true, dataType = "getFollowUserList")
	@PostMapping("/getFollowUserList")
	public Result getFollowUserList(@RequestBody String params) {
		try{
			Object object = SecurityUtils.getSubject().getPrincipal();
			if (object instanceof UserEntity) {
				UserEntity bean = (UserEntity) object;
				UserEntity user = userService.getById(bean.getId());
				
	            
				System.out.println("params参数为：" + params);
				
				JSONObject jsonObject = JSON.parseObject(params);
				String pageNum = String.valueOf(jsonObject.get("pageNum"));
				String pageSize = String.valueOf(jsonObject.get("pageSize"));
				String userName = String.valueOf(jsonObject.get("userName"));//跟进人名称
				
				
				StringUtil.validateIsNull(pageNum, "请输入页码");
				StringUtil.validateIsNull(pageSize, "请输入每页记录数");
				
	            
	            Map<Object, Object> paramMap = new HashMap<Object, Object>();
	            paramMap.put("startRow", PageUtil.getStartRow(pageNum, pageSize));//???????这里还要来回转，很麻烦，可以直接在上面定义此参数就为Integer类型
	            paramMap.put("pageSize", Integer.parseInt(pageSize));     //???????这里还要来回转，很麻烦，可以直接在上面定义此参数就为Integer类型

52. 其实那个全局的事务控制，并不是特别好用，
	第1：很多方法，其实我想使用主义命名，比如waiveCustomerToBusinessGroupSea 放弃客户至业务组公海，这些事务控制就控制不到，自己又没办法在上面单独加注解
	第2：也不是很多方法都会有事务的问题
	所以后续可以考虑，不搞全局事务了
	public boolean realDeleteCustomerByCustomerId(String customerIds); 像这种也匹配不到，你用全局匹配后，就没办法按我的意愿来命名方法了
	
53. 
spring:  
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
	直接一条这样的配置，返回的json，不管是实体类，还是我自定义sql从数据库里面查出来的，返回至前台，localdatetime自动去掉中间的T了，原来自己写的
	//@Configuration
//public class LocalDateTimeFormatConfig {
//
//	@Value("${spring.jackson.date-format:yyyy-MM-dd HH:mm:ss}")
//	private String pattern;
这种方式，居然没起什么作用

注意结合：
		jackson:
		default-property-inclusion: non_null 
		在序列化的时候，这些null的字段就没有了，这个应该是配置那个使用ObjectMapper 这个类进行序列化与反序列化的
		这个一起使用，为空就不返回

54. 




55. 







































mybatis学习（七）——resultType解析
https://www.cnblogs.com/pjfmeng/p/7688172.html


javaWeb后台配置跨域的方法
https://blog.csdn.net/qq_33256688/article/details/79152048


Druid连接池问题：
https://blog.csdn.net/zht741322694/article/details/80959481  使用这个文章，将配在yml配置文件中的wall去掉
https://blog.csdn.net/mayfla/article/details/78774897


@Autowired和@Resource的区别
https://cloud.tencent.com/developer/article/1335837  
https://www.cnblogs.com/think-in-java/p/5474740.html

都知道这两个注解可以实现bean的注入
@Autowired 这个是spring的注解　　　　org.springframework.beans.factory.annotation.Autowired
@Resource 这属于java自带的注解　　　javax.annotation.Resource
@Autowired默认是按照类型来注入的，需要按名字注入的话可以跟@Qualifier搭配使用
@Resource是按照里面的name属性来注入的
上代码吧，更有区分性
针对于面向接口编程的话，一个接口一个实现类是没啥区分性的。
倘若两个实现类，你不指定的话，会报这个错
org.springframework.beans.factory.BeanCreationException bean创建失败
expected single matching bean but found 2: personServiceImpl1,personServiceImpl2
可以写一个实例 一个service接口，两个serviceImpl实现类

其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。

******************************
SpringBoot2.X 整合RedisTemplate 简单实现消息队列
	https://blog.csdn.net/qq_38553333/article/details/82833273
首先：SpringBoot2 以上 整合redis与 Springboot1 有所区别，不用配置redis
在启动的时候，容器中会根据application中redis的配置自动配置，可在项目里直接引用RedisTemplate，，，这个没有使用连接池，可能在真实的项目上会出问题
******************************

优秀shiro博客：
https://z77z.oschina.io/
https://blog.csdn.net/qq_34021712/column/info/26947

Shiro中Session和Cookie的一些思考
https://z77z.oschina.io/2017/03/27/Shiro%E4%B8%ADSession%E5%92%8CCookie%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/

参考文章：
shiro学习
https://blog.csdn.net/u011972171/article/details/80004601
shiro缓存方案讲解：redis集中方案适用于页面没有过多的权限标签，
https://www.cnblogs.com/nuccch/p/8044226.html
shiro实现APP、web统一登录认证和权限管理
https://www.cnblogs.com/sunshine-2015/p/5515429.html
使用redis进行基于shiro的session集群共享
https://www.cnblogs.com/sunshine-2015/p/5686750.html#4126044
集群session共享方案(有shiro共享session的方案)
https://blog.csdn.net/minebk/article/details/73322042
shiro源码篇 - shiro的session共享，你值得拥有(不做集群的话，用不到session共享，我目前的重复认证问题应该不是session共享的问题)
https://www.cnblogs.com/youzhibing/p/9749427.html
Spring Shiro 使用默认的Session会话管理
http://www.cnblogs.com/qsymg/p/9836122.html
Shiro中Session和Cookie的一些思考
https://blog.csdn.net/qq_20954959/article/details/66971090

终极版（这个非常值得看，目前还有剔除前一个账号登录的问题还没做）：
https://blog.csdn.net/zhourenfei17/article/details/83543002
https://blog.csdn.net/qq_20954959/article/details/55260255

SpringBoot使用Redis缓存
https://www.cnblogs.com/gdpuzxs/p/7222309.html


spring boot 集成shiro和redis （绝不坑你）
https://blog.csdn.net/u010514380/article/details/82185451


springboot+shiro+redis缓存+redis会话管理(自定义)
https://blog.csdn.net/xieliaowa9231/article/details/78995465


SpringBoot整合Shiro，权限的动态加载、更新，Shiro-Redis实现分布式Session共享(有单点登录)
https://blog.csdn.net/haoyuyang/article/details/80036989


shiro源码分析（六）CredentialsMatcher 的案例分析   加密方式，
https://lgbolgger.iteye.com/blog/2170522

shiro框架的UsernamePasswordToken与对应Realm中的AuthenticationToken的一点比较
https://www.cnblogs.com/ihaokun/p/10073449.html

Springboot2.0 集成shiro权限管理   
	https://www.cnblogs.com/asker009/p/9471712.html
	
（补漏）Springboot2.0 集成shiro权限管理
	https://www.cnblogs.com/asker009/p/9745470.html
	
Springboot2.x+shiro+redis（Lettuce）整合填坑  
	https://www.cnblogs.com/asker009/p/9813932.html
	
**************整合集群，优先看下面这个文章	
springboot2.x版本整合redis(单机/集群)(使用lettuce)
	https://www.cnblogs.com/007sx/p/10120103.html
redis单机版，哨兵，集群的一些总结
	https://blog.csdn.net/qq_34093116/article/details/80285653
哨兵模式:
	首先哨兵模式是适用于拥有redis主从服务器的情况下的，
集群模式：
	Redis集群中至少需要有三个节点。要保证集群的高可用，需要每个节点有一个备份机。
	Redis集群至少需要6台服务器。
****************单独开发，环境不具备，不好调试，做单机版吧
	
springboot+shiro-redis 使用Redis sentinel（哨兵）主从实现
	http://blog.51cto.com/1745012/2115011
	
实现前端页面数据自动绑定的方法封装: 
	https://www.cnblogs.com/web-MrShi/p/6119164.html

简单实现四郎单点登录（自定义令牌令牌）
https://thinkgem.iteye.com/blog/2194142

**********************************************
前后端分离后，使用token进行接口调用验证处理
**********************************************
目前项目的发展趋势是前后端分离，前端使用vue、React、angular等技术，后端提供接口。

这种方式将后端开发人员从JSP（HTML、css、JS）中解放出来，更专注于后台逻辑的实现。但前后端分离后，由于后端接口是无状态的，那用户信息等敏感数据如何拿到呢？

可以使用token（令牌）机制进行实现，思路如下：

前端第一次登录后，后端使用userid、时间戳等信息组成字符串，然后使用AES等加密技术进行加密，这就是token，然后把token传给前端。以后前端进行其它接口的调用时，就把token带上。后端拦截器取得这个token后，进行解密，如果可正常解密拿到相关数据，就认为是合法请求。同时也拿到了userid，有个userid，或者从缓存中，或者从数据库中取得用户的相关信息。

前后端分离后，前后端分属不同项目，项目的域名则不同，这时会出现跨域问题，可以使用CROS进行跨域处理